<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{ title }}</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#0f1720; --muted:#94a3b8; --accent:#6ee7b7; --accent2:#60a5fa; --danger:#fb7185; --glass: rgba(255,255,255,0.03);
      --fg:#e6eef8; --surface:#111827;
      --radius:14px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#05060a 0%, #0b0f14 60%); color:var(--fg); -webkit-font-smoothing:antialiased;
      display:flex; flex-direction:column; min-height:100vh;
    }

    header{ display:flex; align-items:center; justify-content:space-between; padding:18px 28px; gap:12px }
    .title{ font-weight:700; font-size:40px; letter-spacing:0.02em }
    .subtitle{ color:var(--muted); font-size:26px }

  main{flex:1; display:grid; grid-template-columns:360px 1fr; gap:20px; padding:20px 28px; height: calc(100vh - 96px)}
    @media (max-width:900px){ main{grid-template-columns:1fr} }

    .card{background:linear-gradient(180deg,var(--card), #0b1726); border-radius:var(--radius); padding:18px; box-shadow:0 6px 24px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.03)}

    /* device list */
    .device-column{display:flex; flex-direction:column; gap:12px}
    .device-list{display:flex; flex-direction:column; gap:8px}
    .device-btn{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:18px 16px; border-radius:10px; border:none; cursor:pointer; background:var(--glass); color:var(--fg); transition:transform .12s, box-shadow .12s; min-height:78px; width:100%; font-size:32px}
    .device-btn:hover{transform:translateY(-4px); box-shadow:0 8px 20px rgba(2,6,23,0.5)}
    .device-name{font-weight:600; font-size:30px}
    .device-ip{font-size:24px; color:var(--muted)}

    /* control buttons (all on/off) */
    .control-btn{display:flex; align-items:center; justify-content:center; gap:8px; padding:14px 16px; border-radius:10px; border:none; cursor:pointer; background:linear-gradient(135deg, rgba(110,231,183,0.15), rgba(96,165,250,0.15)); color:var(--fg); transition:transform .12s, box-shadow .12s; font-size:28px; font-weight:600; width:100%}
    .control-btn:hover{transform:translateY(-2px); box-shadow:0 6px 16px rgba(2,6,23,0.4)}
    .control-btn:active{transform:translateY(0)}
    .control-all-on{background:linear-gradient(135deg, rgba(110,231,183,0.25), rgba(110,231,183,0.12))}
    .control-all-off{background:linear-gradient(135deg, rgba(251,113,133,0.25), rgba(251,113,133,0.12))}

    /* weather */
    .weather-header{display:flex; justify-content:space-between; align-items:center}
    .weather-left{display:flex; gap:12px; align-items:center}
    .weather-icon{font-size:56px}
    .weather-now{font-size:44px; font-weight:700}
    .weather-meta{color:var(--muted); font-size:26px}
   /* Charts container: allow proper flexbox shrinking (min-height:0 avoids overflow)
     and make the weather card use column flex layout so charts can share vertical space */
   section[aria-label="weather"]{display:flex; flex-direction:column; min-height:0}
   .charts{display:flex; flex-direction:column; gap:12px; margin-top:12px; flex:1; min-height:0}
   .chart-wrap{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:10px; display:flex; flex-direction:column; min-height:0}
   .chart-wrap canvas{width:100% !important; height:100% !important; display:block}
   /* make the two main charts share vertical space and stretch to the bottom; ensure they can shrink */
   .chart-wrap.flex-grow{flex:1; min-height:0}

    footer{padding:14px 28px; color:var(--muted); font-size:26px; text-align:center}
  </style>
</head>
<body>
  <div class="lcars-bar"></div>

  <main>
    <section class="lcars-card device-column" aria-label="devices">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
        <div style="font-weight:900">Switches</div>
        <div class="badge" style="background:var(--accent3)">Local</div>
      </div>
      <div id="device-list" class="device-list"></div>
      <div style="display:flex; gap:8px; margin-top:12px;">
        <button id="all-lights-on" class="control-btn control-all-on">All On</button>
        <button id="all-lights-off" class="control-btn control-all-off">All Off</button>
      </div>
    </section>

    <section class="lcars-card" aria-label="weather">
      <div class="weather-header">
        <div>
            <div class="weather-title">Weather</div>
            <div class="weather-sub weather-meta" id="weather-location">Loading‚Ä¶</div>
        </div>
        <div style="text-align:right;">
          <div class="weather-meta" id="weather-updated">‚Äî</div>
        </div>
      </div>

      <div class="charts">
        <div style="display:flex;align-items:center;gap:14px;margin-top:10px">
          <div class="weather-left">
            <div id="weather-icon" class="weather-icon">‚Äî</div>
            <div>
              <div id="weather-now" class="weather-now">‚Äî</div>
              <div id="weather-desc" class="weather-meta">‚Äî</div>
            </div>
          </div>
          <div style="margin-left:auto;text-align:right">
            <div id="weather-wind" class="weather-meta">‚Äî</div>
          </div>
        </div>

        <div class="chart-wrap flex-grow">
          <canvas id="tempChart"></canvas>
        </div>
        <div class="chart-wrap flex-grow">
          <canvas id="precipChart"></canvas>
        </div>
        <div class="chart-wrap" style="height:120px">
          <canvas id="cloudChart"></canvas>
        </div>
      </div>
    </section>
  </main>


  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Fetch weather from backend API (keeps data fresh)
    async function fetchWeather() {
      try {
        const res = await fetch('/api/weather');
        if (!res.ok) throw new Error('Weather API error');
        return await res.json();
      } catch (e) {
        console.error('Failed to fetch weather', e);
        return null;
      }
    }

    async function fetchDevices() {
      const res = await fetch('/api/devices');
      if (!res.ok) throw new Error('Failed to load devices');
      return await res.json();
    }

    function cardTemplate(d) {
      const color = d.color || '#FF9F43';
      const symbol = d.symbol || '‚èª';
      const name = d.name || d.ip;
      const state = d.state === true ? 'on' : (d.state === false ? 'off' : 'unknown');
      // visual styles: if on, use configured color; if off, use translucent background
      const bg = state === 'on' ? color : 'transparent';
      const textColor = state === 'on' ? '#061018' : 'var(--fg)';
      const border = state === 'on' ? 'none' : '1px solid rgba(255,255,255,0.04)';
      const dot = state === 'on' ? `<span class="dot" style="width:12px;height:12px;border-radius:50%;background:${color};display:inline-block;margin-right:8px;box-shadow:0 2px 6px ${color}33"></span>` : `<span class="dot" style="width:12px;height:12px;border-radius:50%;background:transparent;border:1px solid rgba(255,255,255,0.06);display:inline-block;margin-right:8px"></span>`;
      return `
        <div class="lcars-card" style="padding:8px;">
          <button class="device-btn" data-ip="${d.ip}" style="background:${bg}; color:${textColor}; border:${border}">
            <div style="display:flex;align-items:center;gap:10px">
              ${dot}
              <div style="text-align:left">
                <div class="device-name">${name}</div>
              </div>
            </div>
            <div class="symbol">${symbol}</div>
          </button>
        </div>
      `;
    }

    async function toggle(ip, btnEl) {
      try {
        btnEl.disabled = true;
        // send toggle request
        const res = await fetch('/api/toggle', {
          method: 'POST', headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ ip })
        });
        const data = await res.json();
        if (!res.ok || !data.ok) throw new Error(data.error || 'Toggle failed');
        // refresh device list to get updated states
        await fetchAndRenderDevices();
      } catch (e) {
        console.error(e);
      } finally {
        btnEl.disabled = false;
      }
    }

    // render device list from fetched devices
    async function fetchAndRenderDevices() {
      const list = document.getElementById('device-list');
      const devices = await fetchDevices();
      list.innerHTML = devices.map(cardTemplate).join('');

      // attach listeners
      list.querySelectorAll('.device-btn').forEach(btn => {
        const ip = btn.getAttribute('data-ip');
        btn.addEventListener('click', () => toggle(ip, btn));
      });
    }

    // toggle all devices to on or off
    async function toggleAllDevices(state) {
      try {
        const devices = await fetchDevices();
        const allBtns = document.querySelectorAll('.device-btn');
        allBtns.forEach(btn => btn.disabled = true);

        // toggle all devices
        for (const d of devices) {
          const ip = d.ip;
          const currentState = d.state;
          // only toggle if state differs from target
          if ((state === 'on' && currentState !== true) || (state === 'off' && currentState !== false)) {
            try {
              const res = await fetch('/api/toggle', {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ ip })
              });
              const data = await res.json();
              if (!res.ok || !data.ok) console.error(`Failed to toggle ${ip}`);
            } catch (e) {
              console.error(`Error toggling ${ip}:`, e);
            }
          }
        }
        // refresh device list to get updated states
        await fetchAndRenderDevices();
      } catch (e) {
        console.error('Failed to toggle all:', e);
      }
    }

    function iconForWeathercode(code) {
      // Very small mapping to emojis ‚Äî replace with SVG/icons as desired
      const map = {
        0: '‚òÄÔ∏è',
        1: 'üå§Ô∏è',
        2: '‚õÖ',
        3: '‚òÅÔ∏è',
        45: 'üå´Ô∏è', 48: 'üå´Ô∏è',
        51: 'üå¶Ô∏è', 53: 'üå¶Ô∏è', 55: 'üåßÔ∏è',
        61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: 'üåßÔ∏è',
        71: 'üå®Ô∏è', 73: 'üå®Ô∏è', 75: '‚ùÑÔ∏è',
        80: 'üåßÔ∏è', 81: 'üåßÔ∏è', 82: 'üåßÔ∏è',
        95: '‚õàÔ∏è', 96: '‚õàÔ∏è', 99: '‚õàÔ∏è'
      };
      return map[code] || 'üåà';
    }

    function windDirToCompass(deg) {
      if (deg === null || deg === undefined) return '';
      const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
      const ix = Math.round(deg / 22.5) % 16; return dirs[ix];
    }

    function renderWeather(weather) {
      const locEl = document.getElementById('weather-location');
      const nowEl = document.getElementById('weather-now');
      const weatherIconEl = document.getElementById('weather-icon');
      const weatherDescEl = document.getElementById('weather-desc');
      const weatherWindEl = document.getElementById('weather-wind');
      const updatedEl = document.getElementById('weather-updated');

      if (!weather) {
        locEl.textContent = 'Unknown location';
        nowEl.textContent = 'Weather unavailable';
        return;
      }

      locEl.textContent = weather.location_name || 'Forecast';

      // Current weather
      const cur = weather.current_weather || null;
      if (cur) {
        const weatherCode = Number(cur.weathercode ?? cur.code ?? null);
        const temp = cur.temperature;
        const wind = cur.windspeed;
        const winddir = cur.winddirection;

        const icon = iconForWeathercode(weatherCode);
        if (weatherIconEl) weatherIconEl.textContent = icon;
        if (nowEl) nowEl.textContent = temp !== undefined ? `${Math.round(Number(temp))}¬∞C` : '‚Äî';
        if (weatherDescEl) weatherDescEl.textContent = '';
        if (weatherWindEl) weatherWindEl.textContent = wind !== undefined ? `${wind} km/h ${windDirToCompass(Number(winddir))}` : '';
      } else {
        nowEl.textContent = '‚Äî';
        if (weatherIconEl) weatherIconEl.textContent = '';
        if (weatherWindEl) weatherWindEl.textContent = '';
      }

      // Use only up to 48 points (backend should already return the correct window)
      const maxPoints = 48;
      let times = (weather.times || []).slice(0, maxPoints);
      let temps = (weather.temperature || []).slice(0, maxPoints);
      let prec = (weather.precipitation || []).slice(0, maxPoints);
      let clouds = (weather.cloudcover || []).slice(0, maxPoints);

      // Ensure the axis starts at the current time and trim to the next 48 hours from now.
      // This creates a "moving window" so as time progresses, the chart automatically shifts forward.
      try {
        const cur = weather.current_weather || null;
        if (cur && cur.time) {
          const nowISO = cur.time; // Open-Meteo current_weather.time is ISO
          const nowDate = new Date(nowISO);
          
          // Find the index where times[i] >= nowISO (i.e., the first point at or after now)
          let startIdx = times.findIndex(t => new Date(t) >= nowDate);
          if (startIdx === -1) startIdx = 0; // If all points are in the past (shouldn't happen), start at 0
          
          // Slice from that index to get the next 48 hours from now
          times = times.slice(startIdx, startIdx + maxPoints);
          temps = temps.slice(startIdx, startIdx + maxPoints);
          prec = prec.slice(startIdx, startIdx + maxPoints);
          clouds = clouds.slice(startIdx, startIdx + maxPoints);
          
          // If we don't have current weather data at the start, prepend it
          if (startIdx > 0 || (times.length > 0 && new Date(times[0]) > nowDate)) {
            const nowTemp = cur.temperature !== undefined ? Number(cur.temperature) : (temps[0] !== undefined ? Number(temps[0]) : null);
            const nowPrec = (prec[0] !== undefined) ? Number(prec[0]) : 0;
            const nowCloud = (clouds[0] !== undefined) ? Number(clouds[0]) : null;
            times = [nowISO].concat(times).slice(0, maxPoints);
            temps = (nowTemp === null ? temps : [nowTemp].concat(temps)).slice(0, maxPoints);
            prec = [nowPrec].concat(prec).slice(0, maxPoints);
            clouds = (nowCloud === null ? clouds : [nowCloud].concat(clouds)).slice(0, maxPoints);
          }
        }
      } catch (e) {
        console.warn('Failed to stitch now into series', e);
      }

      // labels as local hour strings
      const labels = times.map(t => {
        try { return new Date(t).toLocaleString(undefined, { hour: '2-digit', minute: '2-digit' }); } catch(e){ return t; }
      });

      const tempCtx = document.getElementById('tempChart').getContext('2d');
  const precipCtx = document.getElementById('precipChart').getContext('2d');
  const cloudCtx = document.getElementById('cloudChart').getContext('2d');

      if (window._tempChart) window._tempChart.destroy();
      if (window._precipChart) window._precipChart.destroy();

      window._tempChart = new Chart(tempCtx, {
        type: 'line',
        data: { labels: labels, datasets: [{ label: 'Temperature (¬∞C)', data: temps, borderColor: 'rgba(255,159,67,0.95)', backgroundColor: 'rgba(255,159,67,0.12)', tension: 0.25, pointRadius: 0, fill: true }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: false, grid: { display: false } }, y: { beginAtZero: false, ticks: { font: { size: 24 } } } } }
      });

      window._precipChart = new Chart(precipCtx, {
        type: 'line',
        data: { labels: labels, datasets: [{ label: 'Precipitation (mm)', data: prec, borderColor: 'rgba(96,165,250,0.95)', backgroundColor: 'rgba(96,165,250,0.08)', tension: 0.24, pointRadius: 0, fill: true }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: false, grid: { display: false } }, y: { beginAtZero: true, ticks: { font: { size: 24 } } } } }
      });

      window._cloudChart = new Chart(cloudCtx, {
        type: 'line',
        data: { labels: labels, datasets: [{ label: 'Cloud cover (%)', data: clouds, borderColor: 'rgba(148,163,184,0.95)', backgroundColor: 'rgba(148,163,184,0.06)', tension: 0.2, pointRadius: 0, fill: true }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: true, ticks: { font: { size: 26 } } }, y: { beginAtZero: true, max: 100, ticks: { font: { size: 24 } } } } }
      });

      if (updatedEl) updatedEl.textContent = (new Date()).toLocaleString();
    }

    async function init() {
      // populate devices into left column (and refresh periodically)
      await fetchAndRenderDevices();
      // refresh device states every 60 seconds
      setInterval(fetchAndRenderDevices, 60 * 1000);

      // attach listeners to all-on/all-off buttons
      document.getElementById('all-lights-on').addEventListener('click', () => toggleAllDevices('on'));
      document.getElementById('all-lights-off').addEventListener('click', () => toggleAllDevices('off'));

      // fetch and render weather, then refresh periodically
      try {
        const w = await fetchWeather();
        renderWeather(w);
        // refresh every 1 minute to keep the moving window current
        setInterval(async () => {
          const nw = await fetchWeather();
          renderWeather(nw);
        }, 60 * 1000);
      } catch (e) { console.error('Render weather failed', e); }
    }

    init().catch(err => {
      const list = document.getElementById('device-list');
      list.innerHTML = `<div style="opacity:.8">Failed to load devices: ${err.message}</div>`;
      console.error(err);
    });
  </script>
</body>
</html>
